"""
Tests de integración para PauseFeedingSessionUseCase y ResumeFeedingSessionUseCase.

Estos tests verifican que los casos de uso cumplen su contrato:
- Pausar operación activa correctamente
- Reanudar operación pausada correctamente
- Enviar comandos PAUSE/RESUME al PLC
- Validar transiciones de estado correctas
- Mantener el estado de la sesión
"""


import pytest

from application.dtos.feeding_dtos import StartFeedingRequest
from application.use_cases.feeding.resume_feeding_use_case import (
    ResumeFeedingSessionUseCase,
)
from application.use_cases.feeding.start_feeding_use_case import (
    StartFeedingSessionUseCase,
)
from domain.aggregates.cage import Cage
from domain.enums import FeedingMode, OperationStatus
from domain.value_objects import LineId, LineName, CageId, CageName, SiloId
from domain.factories import ComponentFactory
from infrastructure.persistence.mock_repositories import (
    MockFeedingLineRepository,
    MockCageRepository,
    MockFeedingSessionRepository,
    MockFeedingOperationRepository,
)
from infrastructure.services.plc_simulator import PLCSimulator


@pytest.fixture
def repositories():
    """Fixture que proporciona repositorios mock limpios."""
    return {
        "session_repo": MockFeedingSessionRepository(),
        "operation_repo": MockFeedingOperationRepository(),
        "line_repo": MockFeedingLineRepository(),
        "cage_repo": MockCageRepository(),
    }


@pytest.fixture
def machine_service():
    """Fixture que proporciona el simulador PLC."""
    return PLCSimulator(enable_detailed_logging=False)


@pytest.fixture
def pause_use_case(repositories, machine_service):
    """Fixture para caso de uso Pause."""
    return PauseFeedingSessionUseCase(
        session_repository=repositories["session_repo"],
        operation_repository=repositories["operation_repo"],
        machine_service=machine_service,
    )


@pytest.fixture
def resume_use_case(repositories, machine_service):
    """Fixture para caso de uso Resume."""
    return ResumeFeedingSessionUseCase(
        session_repository=repositories["session_repo"],
        operation_repository=repositories["operation_repo"],
        machine_service=machine_service,
    )


@pytest.fixture
def start_use_case(repositories, machine_service):
    """Fixture para caso de uso Start (setup)."""
    return StartFeedingSessionUseCase(
        session_repository=repositories["session_repo"],
        operation_repository=repositories["operation_repo"],
        line_repository=repositories["line_repo"],
        cage_repository=repositories["cage_repo"],
        machine_service=machine_service,
    )


@pytest.fixture
async def setup_running_operation(repositories, start_use_case):
    """Fixture que crea una operación en ejecución."""
    factory = ComponentFactory()

    # Crear línea
    line_id = LineId.generate()
    line = factory.create_feeding_line(
        line_id=line_id,
        line_name=LineName("Línea Test"),
        blower_name="Soplador 1",
        blower_non_feeding_power=50.0,
        blower_blow_before=5,
        blower_blow_after=3,
        selector_name="Selector 1",
        selector_capacity=4,
        selector_fast_speed=80.0,
        selector_slow_speed=20.0,
        doser_configs=[
            {
                "name": "Dosificador 1",
                "assigned_silo_id": SiloId.generate(),
                "doser_type": "volumetric",
                "min_rate": 10.0,
                "max_rate": 100.0,
                "current_rate": 50.0,
            }
        ],
        sensor_configs=[],
    )
    await repositories["line_repo"].save(line)

    # Crear jaula con slot
    cage_id = CageId.generate()
    cage = Cage(name=CageName("Jaula Test"))
    cage._id = cage_id
    cage.assign_to_line(line_id, slot_number=1)
    await repositories["cage_repo"].save(cage)
    line.assign_cage_to_slot(slot_number=1, cage_id=cage_id)
    await repositories["line_repo"].save(line)

    # Iniciar operación
    request = StartFeedingRequest(
        line_id=line_id.value,
        cage_id=cage_id.value,
        mode=FeedingMode.MANUAL,
        target_amount_kg=100.0,
        blower_speed_percentage=70.0,
        dosing_rate_kg_min=50.0,
    )
    operation_id = await start_use_case.execute(request)

    return {"line_id": line_id, "operation_id": operation_id}


class TestPauseFeeding_BasicFlow:
    """Tests para el flujo básico de pausa."""

    @pytest.mark.asyncio
    async def test_pause_feeding_pauses_running_operation(
        self, pause_use_case, setup_running_operation, repositories
    ):
        """Debe pausar una operación en ejecución."""
        infra = await setup_running_operation

        await pause_use_case.execute(infra["line_id"].value)

        # Verificar estado de operación
        session = await repositories["session_repo"].find_active_by_line_id(
            infra["line_id"]
        )
        operation = await repositories["operation_repo"].find_current_by_session(
            session.id
        )

        assert operation is not None
        assert operation.status == OperationStatus.PAUSED

    @pytest.mark.asyncio
    async def test_pause_feeding_sends_pause_to_plc(
        self, pause_use_case, setup_running_operation, machine_service
    ):
        """Debe enviar comando PAUSE al PLC."""
        infra = await setup_running_operation

        # Verificar estado inicial
        status_before = await machine_service.get_status(infra["line_id"])
        assert status_before.is_paused is False

        await pause_use_case.execute(infra["line_id"].value)

        # Verificar que PLC fue pausado
        status_after = await machine_service.get_status(infra["line_id"])
        assert status_after.is_paused is True

    @pytest.mark.asyncio
    async def test_pause_feeding_logs_event(
        self, pause_use_case, setup_running_operation, repositories
    ):
        """Debe registrar evento de PAUSED."""
        infra = await setup_running_operation

        await pause_use_case.execute(infra["line_id"].value)

        # Verificar eventos
        from domain.value_objects import OperationId

        operation = await repositories["operation_repo"].find_by_id(
            OperationId(infra["operation_id"])
        )

        from domain.enums import OperationEventType

        pause_events = [
            e for e in operation.events if e.type == OperationEventType.PAUSED
        ]
        assert len(pause_events) >= 1


class TestPauseFeeding_Validation:
    """Tests para validaciones de pausa."""

    @pytest.mark.asyncio
    async def test_pause_feeding_idempotent_no_session(self, pause_use_case):
        """Debe ser idempotente cuando no hay sesión."""
        fake_line_id = LineId.generate()

        # No debe fallar
        await pause_use_case.execute(fake_line_id.value)

    @pytest.mark.asyncio
    async def test_pause_feeding_fails_on_non_running(
        self, pause_use_case, setup_running_operation, repositories
    ):
        """Debe fallar si la operación no está en RUNNING."""
        infra = await setup_running_operation

        # Pausar una vez
        await pause_use_case.execute(infra["line_id"].value)

        # Intentar pausar de nuevo (ya está pausada)
        with pytest.raises(ValueError) as exc_info:
            await pause_use_case.execute(infra["line_id"].value)

        assert (
            "solo se puede pausar" in str(exc_info.value).lower()
            or "cannot pause" in str(exc_info.value).lower()
        )


class TestResumeFeeding_BasicFlow:
    """Tests para el flujo básico de reanudación."""

    @pytest.mark.asyncio
    async def test_resume_feeding_resumes_paused_operation(
        self, pause_use_case, resume_use_case, setup_running_operation, repositories
    ):
        """Debe reanudar una operación pausada."""
        infra = await setup_running_operation

        # Pausar primero
        await pause_use_case.execute(infra["line_id"].value)

        # Reanudar
        await resume_use_case.execute(infra["line_id"].value)

        # Verificar estado
        session = await repositories["session_repo"].find_active_by_line_id(
            infra["line_id"]
        )
        operation = await repositories["operation_repo"].find_current_by_session(
            session.id
        )

        assert operation.status == OperationStatus.RUNNING

    @pytest.mark.asyncio
    async def test_resume_feeding_sends_resume_to_plc(
        self, pause_use_case, resume_use_case, setup_running_operation, machine_service
    ):
        """Debe enviar comando RESUME al PLC."""
        infra = await setup_running_operation

        # Pausar
        await pause_use_case.execute(infra["line_id"].value)
        status_paused = await machine_service.get_status(infra["line_id"])
        assert status_paused.is_paused is True

        # Reanudar
        await resume_use_case.execute(infra["line_id"].value)
        status_resumed = await machine_service.get_status(infra["line_id"])

        assert status_resumed.is_paused is False
        assert status_resumed.is_running is True

    @pytest.mark.asyncio
    async def test_resume_feeding_logs_event(
        self, pause_use_case, resume_use_case, setup_running_operation, repositories
    ):
        """Debe registrar evento de RESUMED."""
        infra = await setup_running_operation

        await pause_use_case.execute(infra["line_id"].value)
        await resume_use_case.execute(infra["line_id"].value)

        # Verificar eventos
        from domain.value_objects import OperationId

        operation = await repositories["operation_repo"].find_by_id(
            OperationId(infra["operation_id"])
        )

        from domain.enums import OperationEventType

        resume_events = [
            e for e in operation.events if e.type == OperationEventType.RESUMED
        ]
        assert len(resume_events) >= 1


class TestResumeFeeding_Validation:
    """Tests para validaciones de reanudación."""

    @pytest.mark.asyncio
    async def test_resume_feeding_fails_no_session(self, resume_use_case):
        """Debe fallar cuando no hay sesión activa."""
        fake_line_id = LineId.generate()

        with pytest.raises(ValueError) as exc_info:
            await resume_use_case.execute(fake_line_id.value)

        assert "no active session" in str(exc_info.value).lower()

    @pytest.mark.asyncio
    async def test_resume_feeding_fails_on_running(
        self, resume_use_case, setup_running_operation
    ):
        """Debe fallar si la operación ya está en RUNNING."""
        infra = await setup_running_operation

        # Intentar reanudar sin pausar
        with pytest.raises(ValueError) as exc_info:
            await resume_use_case.execute(infra["line_id"].value)

        assert (
            "solo se puede reanudar" in str(exc_info.value).lower()
            or "cannot resume" in str(exc_info.value).lower()
        )


class TestPauseResumeFeeding_Integration:
    """Tests de integración para ciclos completos pause-resume."""

    @pytest.mark.asyncio
    async def test_multiple_pause_resume_cycles(
        self, pause_use_case, resume_use_case, setup_running_operation, repositories
    ):
        """Debe soportar múltiples ciclos de pausa-reanudación."""
        infra = await setup_running_operation

        # Ciclo 1
        await pause_use_case.execute(infra["line_id"].value)
        await resume_use_case.execute(infra["line_id"].value)

        # Ciclo 2
        await pause_use_case.execute(infra["line_id"].value)
        await resume_use_case.execute(infra["line_id"].value)

        # Verificar estado final
        session = await repositories["session_repo"].find_active_by_line_id(
            infra["line_id"]
        )
        operation = await repositories["operation_repo"].find_current_by_session(
            session.id
        )

        assert operation.status == OperationStatus.RUNNING

        # Verificar eventos (STARTED + 2xPAUSED + 2xRESUMED = 5 eventos)
        from domain.value_objects import OperationId

        operation_full = await repositories["operation_repo"].find_by_id(
            OperationId(infra["operation_id"])
        )
        # Verificar eventos (STARTED + 2xPAUSED + 2xRESUMED = 5 eventos)
        from domain.value_objects import OperationId
        operation_full = await repositories['operation_repo'].find_by_id(OperationId(infra['operation_id']))
        assert len(operation_full.events) >= 5
